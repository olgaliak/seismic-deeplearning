<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="9" hostname="mzmlvm" name="pytest" skipped="0" tests="14" time="0.974" timestamp="2020-02-04T22:24:04.081051"><testcase classname="test.test_dataprocessing_scripts" file="test/test_dataprocessing_scripts.py" line="37" name="test_process_all_files_exits_0" time="0.011"><failure message="assert 0 == 4
 +  where 0 = len([])">filedir = None

    def test_process_all_files_exits_0(filedir):
        &quot;&quot;&quot;
        Run process_all_files and checks that it returns with 0 exit code
        :param function filedir: fixture for setup and cleanup
        &quot;&quot;&quot;
    
        # Setup
        os.makedirs(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;, &quot;input&quot;), exist_ok=True)
        args = Namespace(segy_file=&quot;listric2-conditioned.segy&quot;,
            segy_files_list=None,
            local_input=True,
            account_name=&quot;not used in this test&quot;,
            account_key=&quot;not used in this test&quot;,
            input_path=&quot;test_data&quot;,
            tmp_dir=OUTPUTDIR,
            output_path=&quot;seismicdata/cubes_test&quot;,
            iline=189,
            xline=193,
            debug=False,
            cube_size=128,
            stride=128,
            local_output=True,
            remote_run=False,
            input=&apos;./src/test&apos;)
        process_all_files.main(args)
    
        # Validate
        npy_files = test_util.get_npy_files(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;,
            &quot;cubes_test&quot;, &quot;conditioned&quot;, &quot;listric2&quot;))
&gt;       assert(len(npy_files) == 4)
E       assert 0 == 4
E        +  where 0 = len([])

test/test_dataprocessing_scripts.py:67: AssertionError</failure><system-err>Traceback (most recent call last):
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 278, in _process_files
    local_output_dir, localfile = _download(file)
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 137, in _download
    shutil.copy(input_file, localfile)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 248, in copy
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 120, in copyfile
    with open(src, &apos;rb&apos;) as fsrc:
FileNotFoundError: [Errno 2] No such file or directory: &apos;./src/test/test_data/listric2-conditioned.segy&apos;
</system-err></testcase><testcase classname="test.test_dataprocessing_scripts" file="test/test_dataprocessing_scripts.py" line="69" name="test_process_all_files_exits_0_for_single_npy_file" time="0.003"><failure message="assert 0 == 1
 +  where 0 = len([])">filedir = None

    def test_process_all_files_exits_0_for_single_npy_file(filedir):
        &quot;&quot;&quot;
        Run process_all_files to generate only one npy file
        :param function filedir: fixture for setup and cleanup
        &quot;&quot;&quot;
    
        # Setup
        os.makedirs(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;, &quot;input&quot;), exist_ok=True)
        args = Namespace(segy_file=&quot;listric2-conditioned.segy&quot;,
            segy_files_list=None,
            local_input=True,
            account_name=&quot;not used in this test&quot;,
            account_key=&quot;not used in this test&quot;,
            input_path=&quot;test_data&quot;,
            tmp_dir=OUTPUTDIR,
            output_path=&quot;seismicdata/cubes_test&quot;,
            iline=189,
            xline=193,
            cube_size=-1,
            debug=False,
            stride=128,
            local_output=True,
            remote_run=False,
            input=&apos;./src/test&apos;)
        process_all_files.main(args)
    
        # Validate
        npy_files = test_util.get_npy_files(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;,
            &quot;cubes_test&quot;, &quot;conditioned&quot;, &quot;listric2&quot;))
&gt;       assert(len(npy_files) == 1)
E       assert 0 == 1
E        +  where 0 = len([])

test/test_dataprocessing_scripts.py:99: AssertionError</failure><system-err>Traceback (most recent call last):
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 278, in _process_files
    local_output_dir, localfile = _download(file)
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 137, in _download
    shutil.copy(input_file, localfile)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 248, in copy
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 120, in copyfile
    with open(src, &apos;rb&apos;) as fsrc:
FileNotFoundError: [Errno 2] No such file or directory: &apos;./src/test/test_data/listric2-conditioned.segy&apos;
</system-err></testcase><testcase classname="test.test_dataprocessing_scripts" file="test/test_dataprocessing_scripts.py" line="106" name="test_process_all_files_normalizes_data" time="0.002"><failure message="assert 0 == 4
 +  where 0 = len([])">filedir = None

    def test_process_all_files_normalizes_data(filedir):
        &quot;&quot;&quot;
        Run process_all_files and checks that it correctly normalizes data
        :param function filedir: fixture for setup and cleanup
        &quot;&quot;&quot;
    
        # Setup
        os.makedirs(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;, &quot;input&quot;), exist_ok=True)
        args = Namespace(segy_file=&quot;listric2-conditioned.segy&quot;,
            segy_files_list=None,
            local_input=True,
            account_name=&quot;not used in this test&quot;,
            account_key=&quot;not used in this test&quot;,
            input_path=&quot;test_data&quot;,
            tmp_dir=OUTPUTDIR,
            output_path=&quot;seismicdata/cubes_test&quot;,
            iline=189,
            xline=193,
            debug=True,
            cube_size=128,
            stride=128,
            local_output=True,
            remote_run=False,
            input=&apos;./src/test&apos;)
        process_all_files.main(args)
    
        # Validate
        npy_files = test_util.get_npy_files(os.path.join(OUTPUTDIR, &quot;seismicdata&quot;,
            &quot;cubes_test&quot;, &quot;conditioned&quot;, &quot;listric2&quot;))
&gt;       assert(len(npy_files) == 4)
E       assert 0 == 4
E        +  where 0 = len([])

test/test_dataprocessing_scripts.py:136: AssertionError</failure><system-err>Traceback (most recent call last):
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 278, in _process_files
    local_output_dir, localfile = _download(file)
  File &quot;/home/localadmin/cse_deepseismic/contrib/segyconverter/process_all_files.py&quot;, line 137, in _download
    shutil.copy(input_file, localfile)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 248, in copy
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File &quot;/anaconda/envs/py37_default/lib/python3.7/shutil.py&quot;, line 120, in copyfile
    with open(src, &apos;rb&apos;) as fsrc:
FileNotFoundError: [Errno 2] No such file or directory: &apos;./src/test/test_data/listric2-conditioned.segy&apos;
</system-err></testcase><testcase classname="test.test_dataprocessing_scripts" file="test/test_dataprocessing_scripts.py" line="142" name="test_validate_args_should_fail_for_invalid_segy_file_list" time="0.001"><system-out>segy_files_list file does not exist
</system-out></testcase><testcase classname="test.test_dataprocessing_scripts" file="test/test_dataprocessing_scripts.py" line="169" name="test_validate_args_should_fail_for_segy_files_list_and_segy_file" time="0.001"><system-out>segy_file and segy_files_list
</system-out></testcase><testcase classname="test.test_segyextract_basicfunctions" file="test/test_segyextract_basicfunctions.py" line="7" name="test_remove_duplicates_should_keep_order" time="0.001"></testcase><testcase classname="test.test_segyextract_basicfunctions" file="test/test_segyextract_basicfunctions.py" line="17" name="test_identify_fast_direction_should_handle_xline_sequence_1" time="0.003"></testcase><testcase classname="test.test_segyextract_basicfunctions" file="test/test_segyextract_basicfunctions.py" line="27" name="test_identify_fast_direction_should_handle_xline_sequence_2" time="0.002"></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="36" name="test_get_segy_metadata_should_return_correct_metadata" time="0.014"><failure message="assert 10 == 501">def test_get_segy_metadata_should_return_correct_metadata():
    
        # setup
        filename = &quot;./test/test_data/normalsegy.segy&quot;
        inline_byte_loc = 189
        xline_byte_loc = 193
    
        # test
        fast_indexes, slow_indexes, trace_headers, sample_size = segyextract.get_segy_metadata(
            filename, inline_byte_loc, xline_byte_loc)
    
        # validate
&gt;       assert(sample_size == 501)
E       assert 10 == 501

test/test_segyextract_fileio.py:49: AssertionError</failure></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="58" name="test_process_segy_data_should_create_cube_size_equal_to_segy" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory">filedir = None

    def test_process_segy_data_should_create_cube_size_equal_to_segy(filedir):
        &quot;&quot;&quot;
        Create single npy file for segy and validate size
        :param function filedir: pytest fixture for local test directory cleanup
        &quot;&quot;&quot;
&gt;       segyextract.process_segy_data_into_single_array(FILENAME, OUTPUTDIR, PREFIX)

test/test_segyextract_fileio.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
utils/segyextract.py:61: in process_segy_data_into_single_array
    fast_distinct, slow_distinct, trace_headers, sampledepth = get_segy_metadata(input_file, iline, xline)
utils/segyextract.py:32: in get_segy_metadata
    with segyio.open(input_file, ignore_geometry=True) as segy_file:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = &apos;src/test/test_data/listric2-input.segy&apos;, mode = &apos;r&apos;, iline = 189, xline = 193, strict = True
ignore_geometry = True, endian = &apos;big&apos;

    def open(filename, mode=&quot;r&quot;, iline = 189,
                                 xline = 193,
                                 strict = True,
                                 ignore_geometry = False,
                                 endian = &apos;big&apos;):
        &quot;&quot;&quot;Open a segy file.
    
        Opens a segy file and tries to figure out its sorting, inline numbers,
        crossline numbers, and offsets, and enables reading and writing to this
        file in a simple manner.
    
        For reading, the access mode `r` is preferred. All write operations will
        raise an exception. For writing, the mode `r+` is preferred (as `rw` would
        truncate the file). Any mode with `w` will raise an error. The modes used
        are standard C file modes; please refer to that documentation for a
        complete reference.
    
        Open should be used together with python&apos;s ``with`` statement. Please refer
        to the examples. When the ``with`` statement is used the file will
        automatically be closed when the routine completes or an exception is
        raised.
    
        By default, segyio tries to open in ``strict`` mode. This means the file will
        be assumed to represent a geometry with consistent inline, crosslines and
        offsets. If strict is False, segyio will still try to establish a geometry,
        but it won&apos;t abort if it fails. When in non-strict mode is opened,
        geometry-dependent modes such as iline will raise an error.
    
        If ``ignore_geometry=True``, segyio will *not* try to build iline/xline or
        other geometry related structures, which leads to faster opens. This is
        essentially the same as using ``strict=False`` on a file that has no
        geometry.
    
        Parameters
        ----------
    
        filename : str
            Path to file to open
    
        mode : {&apos;r&apos;, &apos;r+&apos;}
            File access mode, read-only (&apos;r&apos;, default) or read-write (&apos;r+&apos;)
    
        iline : int or segyio.TraceField
            Inline number field in the trace headers. Defaults to 189 as per the
            SEG-Y rev1 specification
    
        xline : int or segyio.TraceField
            Crossline number field in the trace headers. Defaults to 193 as per the
            SEG-Y rev1 specification
    
        strict : bool, optional
            Abort if a geometry cannot be inferred. Defaults to True.
    
        ignore_geometry : bool, optional
            Opt out on building geometry information, useful for e.g. shot
            organised files. Defaults to False.
    
        endian : {&apos;big&apos;, &apos;msb&apos;, &apos;little&apos;, &apos;lsb&apos;}
            File endianness, big/msb (default) or little/lsb
    
        Returns
        -------
    
        file : segyio.SegyFile
            An open segyio file handle
    
        Raises
        ------
    
        ValueError
            If the mode string contains &apos;w&apos;, as it would truncate the file
    
        Notes
        -----
    
        .. versionadded:: 1.1
    
        .. versionchanged:: 1.8
            endian argument
    
        When a file is opened non-strict, only raw traces access is allowed, and
        using modes such as ``iline`` raise an error.
    
    
        Examples
        --------
    
        Open a file in read-only mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r&quot;) as f:
        ...     print(f.ilines)
        ...
        [1, 2, 3, 4, 5]
    
        Open a file in read-write mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r+&quot;) as f:
        ...     f.trace = np.arange(100)
    
        Open two files at once:
    
        &gt;&gt;&gt; with segyio.open(src_path) as src, segyio.open(dst_path, &quot;r+&quot;) as dst:
        ...     dst.trace = src.trace # copy all traces from src to dst
    
        Open a file little-endian file:
    
        &gt;&gt;&gt; with segyio.open(path, endian = &apos;little&apos;) as f:
        ...     f.trace[0]
    
        &quot;&quot;&quot;
    
        if &apos;w&apos; in mode:
            problem = &apos;w in mode would truncate the file&apos;
            solution = &apos;use r+ to open in read-write&apos;
            raise ValueError(&apos;, &apos;.join((problem, solution)))
    
        endians = {
            &apos;little&apos;: 256, # (1 &lt;&lt; 8)
            &apos;lsb&apos;: 256,
            &apos;big&apos;: 0,
            &apos;msb&apos;: 0,
        }
    
        if endian not in endians:
            problem = &apos;unknown endianness {}, expected one of: &apos;
            opts = &apos; &apos;.join(endians.keys())
            raise ValueError(problem.format(endian) + opts)
    
        from . import _segyio
&gt;       fd = _segyio.segyiofd(str(filename), mode, endians[endian])
E       FileNotFoundError: [Errno 2] No such file or directory

/anaconda/envs/py37_default/lib/python3.7/site-packages/segyio/open.py:162: FileNotFoundError</failure></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="75" name="test_process_segy_data_should_write_npy_files_for_n_equals_128_stride_64" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory">filedir = None

    def test_process_segy_data_should_write_npy_files_for_n_equals_128_stride_64(filedir):
        &quot;&quot;&quot;
        Break data up into size n=128 size blocks and validate against original segy
        file. This size of block causes the code to write 1 x 4 npy files
        :param function filedir: pytest fixture for local test directory cleanup
        &quot;&quot;&quot;
        # setup
        n_points = 128
        stride = 64
    
        # test
        segyextract.process_segy_data(FILENAME, OUTPUTDIR, PREFIX, n_points=n_points,
&gt;           stride=stride)

test/test_segyextract_fileio.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
utils/segyextract.py:106: in process_segy_data
    fast_indexes, slow_indexes, trace_headers, _ = get_segy_metadata(input_file, iline, xline)
utils/segyextract.py:32: in get_segy_metadata
    with segyio.open(input_file, ignore_geometry=True) as segy_file:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = &apos;src/test/test_data/listric2-input.segy&apos;, mode = &apos;r&apos;, iline = 189, xline = 193, strict = True
ignore_geometry = True, endian = &apos;big&apos;

    def open(filename, mode=&quot;r&quot;, iline = 189,
                                 xline = 193,
                                 strict = True,
                                 ignore_geometry = False,
                                 endian = &apos;big&apos;):
        &quot;&quot;&quot;Open a segy file.
    
        Opens a segy file and tries to figure out its sorting, inline numbers,
        crossline numbers, and offsets, and enables reading and writing to this
        file in a simple manner.
    
        For reading, the access mode `r` is preferred. All write operations will
        raise an exception. For writing, the mode `r+` is preferred (as `rw` would
        truncate the file). Any mode with `w` will raise an error. The modes used
        are standard C file modes; please refer to that documentation for a
        complete reference.
    
        Open should be used together with python&apos;s ``with`` statement. Please refer
        to the examples. When the ``with`` statement is used the file will
        automatically be closed when the routine completes or an exception is
        raised.
    
        By default, segyio tries to open in ``strict`` mode. This means the file will
        be assumed to represent a geometry with consistent inline, crosslines and
        offsets. If strict is False, segyio will still try to establish a geometry,
        but it won&apos;t abort if it fails. When in non-strict mode is opened,
        geometry-dependent modes such as iline will raise an error.
    
        If ``ignore_geometry=True``, segyio will *not* try to build iline/xline or
        other geometry related structures, which leads to faster opens. This is
        essentially the same as using ``strict=False`` on a file that has no
        geometry.
    
        Parameters
        ----------
    
        filename : str
            Path to file to open
    
        mode : {&apos;r&apos;, &apos;r+&apos;}
            File access mode, read-only (&apos;r&apos;, default) or read-write (&apos;r+&apos;)
    
        iline : int or segyio.TraceField
            Inline number field in the trace headers. Defaults to 189 as per the
            SEG-Y rev1 specification
    
        xline : int or segyio.TraceField
            Crossline number field in the trace headers. Defaults to 193 as per the
            SEG-Y rev1 specification
    
        strict : bool, optional
            Abort if a geometry cannot be inferred. Defaults to True.
    
        ignore_geometry : bool, optional
            Opt out on building geometry information, useful for e.g. shot
            organised files. Defaults to False.
    
        endian : {&apos;big&apos;, &apos;msb&apos;, &apos;little&apos;, &apos;lsb&apos;}
            File endianness, big/msb (default) or little/lsb
    
        Returns
        -------
    
        file : segyio.SegyFile
            An open segyio file handle
    
        Raises
        ------
    
        ValueError
            If the mode string contains &apos;w&apos;, as it would truncate the file
    
        Notes
        -----
    
        .. versionadded:: 1.1
    
        .. versionchanged:: 1.8
            endian argument
    
        When a file is opened non-strict, only raw traces access is allowed, and
        using modes such as ``iline`` raise an error.
    
    
        Examples
        --------
    
        Open a file in read-only mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r&quot;) as f:
        ...     print(f.ilines)
        ...
        [1, 2, 3, 4, 5]
    
        Open a file in read-write mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r+&quot;) as f:
        ...     f.trace = np.arange(100)
    
        Open two files at once:
    
        &gt;&gt;&gt; with segyio.open(src_path) as src, segyio.open(dst_path, &quot;r+&quot;) as dst:
        ...     dst.trace = src.trace # copy all traces from src to dst
    
        Open a file little-endian file:
    
        &gt;&gt;&gt; with segyio.open(path, endian = &apos;little&apos;) as f:
        ...     f.trace[0]
    
        &quot;&quot;&quot;
    
        if &apos;w&apos; in mode:
            problem = &apos;w in mode would truncate the file&apos;
            solution = &apos;use r+ to open in read-write&apos;
            raise ValueError(&apos;, &apos;.join((problem, solution)))
    
        endians = {
            &apos;little&apos;: 256, # (1 &lt;&lt; 8)
            &apos;lsb&apos;: 256,
            &apos;big&apos;: 0,
            &apos;msb&apos;: 0,
        }
    
        if endian not in endians:
            problem = &apos;unknown endianness {}, expected one of: &apos;
            opts = &apos; &apos;.join(endians.keys())
            raise ValueError(problem.format(endian) + opts)
    
        from . import _segyio
&gt;       fd = _segyio.segyiofd(str(filename), mode, endians[endian])
E       FileNotFoundError: [Errno 2] No such file or directory

/anaconda/envs/py37_default/lib/python3.7/site-packages/segyio/open.py:162: FileNotFoundError</failure></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="93" name="test_process_segy_data_should_write_npy_files_for_n_equals_128" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory">filedir = None

    def test_process_segy_data_should_write_npy_files_for_n_equals_128(filedir):
        &quot;&quot;&quot;
        Break data up into size n=128 size blocks and validate against original segy
        file. This size of block causes the code to write 1 x 4 npy files
        :param function filedir: pytest fixture for local test directory cleanup
        &quot;&quot;&quot;
        # setup
        n_points = 128
    
        # test
&gt;       segyextract.process_segy_data(FILENAME, OUTPUTDIR, PREFIX)

test/test_segyextract_fileio.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
utils/segyextract.py:106: in process_segy_data
    fast_indexes, slow_indexes, trace_headers, _ = get_segy_metadata(input_file, iline, xline)
utils/segyextract.py:32: in get_segy_metadata
    with segyio.open(input_file, ignore_geometry=True) as segy_file:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = &apos;src/test/test_data/listric2-input.segy&apos;, mode = &apos;r&apos;, iline = 189, xline = 193, strict = True
ignore_geometry = True, endian = &apos;big&apos;

    def open(filename, mode=&quot;r&quot;, iline = 189,
                                 xline = 193,
                                 strict = True,
                                 ignore_geometry = False,
                                 endian = &apos;big&apos;):
        &quot;&quot;&quot;Open a segy file.
    
        Opens a segy file and tries to figure out its sorting, inline numbers,
        crossline numbers, and offsets, and enables reading and writing to this
        file in a simple manner.
    
        For reading, the access mode `r` is preferred. All write operations will
        raise an exception. For writing, the mode `r+` is preferred (as `rw` would
        truncate the file). Any mode with `w` will raise an error. The modes used
        are standard C file modes; please refer to that documentation for a
        complete reference.
    
        Open should be used together with python&apos;s ``with`` statement. Please refer
        to the examples. When the ``with`` statement is used the file will
        automatically be closed when the routine completes or an exception is
        raised.
    
        By default, segyio tries to open in ``strict`` mode. This means the file will
        be assumed to represent a geometry with consistent inline, crosslines and
        offsets. If strict is False, segyio will still try to establish a geometry,
        but it won&apos;t abort if it fails. When in non-strict mode is opened,
        geometry-dependent modes such as iline will raise an error.
    
        If ``ignore_geometry=True``, segyio will *not* try to build iline/xline or
        other geometry related structures, which leads to faster opens. This is
        essentially the same as using ``strict=False`` on a file that has no
        geometry.
    
        Parameters
        ----------
    
        filename : str
            Path to file to open
    
        mode : {&apos;r&apos;, &apos;r+&apos;}
            File access mode, read-only (&apos;r&apos;, default) or read-write (&apos;r+&apos;)
    
        iline : int or segyio.TraceField
            Inline number field in the trace headers. Defaults to 189 as per the
            SEG-Y rev1 specification
    
        xline : int or segyio.TraceField
            Crossline number field in the trace headers. Defaults to 193 as per the
            SEG-Y rev1 specification
    
        strict : bool, optional
            Abort if a geometry cannot be inferred. Defaults to True.
    
        ignore_geometry : bool, optional
            Opt out on building geometry information, useful for e.g. shot
            organised files. Defaults to False.
    
        endian : {&apos;big&apos;, &apos;msb&apos;, &apos;little&apos;, &apos;lsb&apos;}
            File endianness, big/msb (default) or little/lsb
    
        Returns
        -------
    
        file : segyio.SegyFile
            An open segyio file handle
    
        Raises
        ------
    
        ValueError
            If the mode string contains &apos;w&apos;, as it would truncate the file
    
        Notes
        -----
    
        .. versionadded:: 1.1
    
        .. versionchanged:: 1.8
            endian argument
    
        When a file is opened non-strict, only raw traces access is allowed, and
        using modes such as ``iline`` raise an error.
    
    
        Examples
        --------
    
        Open a file in read-only mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r&quot;) as f:
        ...     print(f.ilines)
        ...
        [1, 2, 3, 4, 5]
    
        Open a file in read-write mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r+&quot;) as f:
        ...     f.trace = np.arange(100)
    
        Open two files at once:
    
        &gt;&gt;&gt; with segyio.open(src_path) as src, segyio.open(dst_path, &quot;r+&quot;) as dst:
        ...     dst.trace = src.trace # copy all traces from src to dst
    
        Open a file little-endian file:
    
        &gt;&gt;&gt; with segyio.open(path, endian = &apos;little&apos;) as f:
        ...     f.trace[0]
    
        &quot;&quot;&quot;
    
        if &apos;w&apos; in mode:
            problem = &apos;w in mode would truncate the file&apos;
            solution = &apos;use r+ to open in read-write&apos;
            raise ValueError(&apos;, &apos;.join((problem, solution)))
    
        endians = {
            &apos;little&apos;: 256, # (1 &lt;&lt; 8)
            &apos;lsb&apos;: 256,
            &apos;big&apos;: 0,
            &apos;msb&apos;: 0,
        }
    
        if endian not in endians:
            problem = &apos;unknown endianness {}, expected one of: &apos;
            opts = &apos; &apos;.join(endians.keys())
            raise ValueError(problem.format(endian) + opts)
    
        from . import _segyio
&gt;       fd = _segyio.segyiofd(str(filename), mode, endians[endian])
E       FileNotFoundError: [Errno 2] No such file or directory

/anaconda/envs/py37_default/lib/python3.7/site-packages/segyio/open.py:162: FileNotFoundError</failure></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="115" name="test_process_segy_data_should_write_npy_files_for_n_equals_64" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory">filedir = None

    def test_process_segy_data_should_write_npy_files_for_n_equals_64(filedir):
        &quot;&quot;&quot;
        Break data up into size n=64 size blocks and validate against original segy
        file. This size of block causes the code to write 1 x 8 npy files
        :param function filedir: pytest fixture for local test directory cleanup
        &quot;&quot;&quot;
        # setup
    
        n_points = 64
        expected_file_count = 8
        # test
&gt;       segyextract.process_segy_data(FILENAME, OUTPUTDIR, PREFIX, n_points=n_points, stride=n_points)

test/test_segyextract_fileio.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
utils/segyextract.py:106: in process_segy_data
    fast_indexes, slow_indexes, trace_headers, _ = get_segy_metadata(input_file, iline, xline)
utils/segyextract.py:32: in get_segy_metadata
    with segyio.open(input_file, ignore_geometry=True) as segy_file:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = &apos;src/test/test_data/listric2-input.segy&apos;, mode = &apos;r&apos;, iline = 189, xline = 193, strict = True
ignore_geometry = True, endian = &apos;big&apos;

    def open(filename, mode=&quot;r&quot;, iline = 189,
                                 xline = 193,
                                 strict = True,
                                 ignore_geometry = False,
                                 endian = &apos;big&apos;):
        &quot;&quot;&quot;Open a segy file.
    
        Opens a segy file and tries to figure out its sorting, inline numbers,
        crossline numbers, and offsets, and enables reading and writing to this
        file in a simple manner.
    
        For reading, the access mode `r` is preferred. All write operations will
        raise an exception. For writing, the mode `r+` is preferred (as `rw` would
        truncate the file). Any mode with `w` will raise an error. The modes used
        are standard C file modes; please refer to that documentation for a
        complete reference.
    
        Open should be used together with python&apos;s ``with`` statement. Please refer
        to the examples. When the ``with`` statement is used the file will
        automatically be closed when the routine completes or an exception is
        raised.
    
        By default, segyio tries to open in ``strict`` mode. This means the file will
        be assumed to represent a geometry with consistent inline, crosslines and
        offsets. If strict is False, segyio will still try to establish a geometry,
        but it won&apos;t abort if it fails. When in non-strict mode is opened,
        geometry-dependent modes such as iline will raise an error.
    
        If ``ignore_geometry=True``, segyio will *not* try to build iline/xline or
        other geometry related structures, which leads to faster opens. This is
        essentially the same as using ``strict=False`` on a file that has no
        geometry.
    
        Parameters
        ----------
    
        filename : str
            Path to file to open
    
        mode : {&apos;r&apos;, &apos;r+&apos;}
            File access mode, read-only (&apos;r&apos;, default) or read-write (&apos;r+&apos;)
    
        iline : int or segyio.TraceField
            Inline number field in the trace headers. Defaults to 189 as per the
            SEG-Y rev1 specification
    
        xline : int or segyio.TraceField
            Crossline number field in the trace headers. Defaults to 193 as per the
            SEG-Y rev1 specification
    
        strict : bool, optional
            Abort if a geometry cannot be inferred. Defaults to True.
    
        ignore_geometry : bool, optional
            Opt out on building geometry information, useful for e.g. shot
            organised files. Defaults to False.
    
        endian : {&apos;big&apos;, &apos;msb&apos;, &apos;little&apos;, &apos;lsb&apos;}
            File endianness, big/msb (default) or little/lsb
    
        Returns
        -------
    
        file : segyio.SegyFile
            An open segyio file handle
    
        Raises
        ------
    
        ValueError
            If the mode string contains &apos;w&apos;, as it would truncate the file
    
        Notes
        -----
    
        .. versionadded:: 1.1
    
        .. versionchanged:: 1.8
            endian argument
    
        When a file is opened non-strict, only raw traces access is allowed, and
        using modes such as ``iline`` raise an error.
    
    
        Examples
        --------
    
        Open a file in read-only mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r&quot;) as f:
        ...     print(f.ilines)
        ...
        [1, 2, 3, 4, 5]
    
        Open a file in read-write mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r+&quot;) as f:
        ...     f.trace = np.arange(100)
    
        Open two files at once:
    
        &gt;&gt;&gt; with segyio.open(src_path) as src, segyio.open(dst_path, &quot;r+&quot;) as dst:
        ...     dst.trace = src.trace # copy all traces from src to dst
    
        Open a file little-endian file:
    
        &gt;&gt;&gt; with segyio.open(path, endian = &apos;little&apos;) as f:
        ...     f.trace[0]
    
        &quot;&quot;&quot;
    
        if &apos;w&apos; in mode:
            problem = &apos;w in mode would truncate the file&apos;
            solution = &apos;use r+ to open in read-write&apos;
            raise ValueError(&apos;, &apos;.join((problem, solution)))
    
        endians = {
            &apos;little&apos;: 256, # (1 &lt;&lt; 8)
            &apos;lsb&apos;: 256,
            &apos;big&apos;: 0,
            &apos;msb&apos;: 0,
        }
    
        if endian not in endians:
            problem = &apos;unknown endianness {}, expected one of: &apos;
            opts = &apos; &apos;.join(endians.keys())
            raise ValueError(problem.format(endian) + opts)
    
        from . import _segyio
&gt;       fd = _segyio.segyiofd(str(filename), mode, endians[endian])
E       FileNotFoundError: [Errno 2] No such file or directory

/anaconda/envs/py37_default/lib/python3.7/site-packages/segyio/open.py:162: FileNotFoundError</failure></testcase><testcase classname="test.test_segyextract_fileio" file="test/test_segyextract_fileio.py" line="138" name="test_process_segy_data_should_write_npy_files_for_n_equals_16" time="0.001"><failure message="FileNotFoundError: [Errno 2] No such file or directory">filedir = None

    def test_process_segy_data_should_write_npy_files_for_n_equals_16(filedir):
        &quot;&quot;&quot;
        Break data up into size n=16 size blocks and validate against original segy
        file. This size of block causes the code to write 2 x 4 x 32 npy files.
        :param function filedir: pytest fixture for local test directory cleanup
        &quot;&quot;&quot;
        # setup
        n_points = 16
    
        # test
        segyextract.process_segy_data(FILENAME, OUTPUTDIR, PREFIX,
&gt;           n_points=n_points, stride=n_points)

test/test_segyextract_fileio.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
utils/segyextract.py:106: in process_segy_data
    fast_indexes, slow_indexes, trace_headers, _ = get_segy_metadata(input_file, iline, xline)
utils/segyextract.py:32: in get_segy_metadata
    with segyio.open(input_file, ignore_geometry=True) as segy_file:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = &apos;src/test/test_data/listric2-input.segy&apos;, mode = &apos;r&apos;, iline = 189, xline = 193, strict = True
ignore_geometry = True, endian = &apos;big&apos;

    def open(filename, mode=&quot;r&quot;, iline = 189,
                                 xline = 193,
                                 strict = True,
                                 ignore_geometry = False,
                                 endian = &apos;big&apos;):
        &quot;&quot;&quot;Open a segy file.
    
        Opens a segy file and tries to figure out its sorting, inline numbers,
        crossline numbers, and offsets, and enables reading and writing to this
        file in a simple manner.
    
        For reading, the access mode `r` is preferred. All write operations will
        raise an exception. For writing, the mode `r+` is preferred (as `rw` would
        truncate the file). Any mode with `w` will raise an error. The modes used
        are standard C file modes; please refer to that documentation for a
        complete reference.
    
        Open should be used together with python&apos;s ``with`` statement. Please refer
        to the examples. When the ``with`` statement is used the file will
        automatically be closed when the routine completes or an exception is
        raised.
    
        By default, segyio tries to open in ``strict`` mode. This means the file will
        be assumed to represent a geometry with consistent inline, crosslines and
        offsets. If strict is False, segyio will still try to establish a geometry,
        but it won&apos;t abort if it fails. When in non-strict mode is opened,
        geometry-dependent modes such as iline will raise an error.
    
        If ``ignore_geometry=True``, segyio will *not* try to build iline/xline or
        other geometry related structures, which leads to faster opens. This is
        essentially the same as using ``strict=False`` on a file that has no
        geometry.
    
        Parameters
        ----------
    
        filename : str
            Path to file to open
    
        mode : {&apos;r&apos;, &apos;r+&apos;}
            File access mode, read-only (&apos;r&apos;, default) or read-write (&apos;r+&apos;)
    
        iline : int or segyio.TraceField
            Inline number field in the trace headers. Defaults to 189 as per the
            SEG-Y rev1 specification
    
        xline : int or segyio.TraceField
            Crossline number field in the trace headers. Defaults to 193 as per the
            SEG-Y rev1 specification
    
        strict : bool, optional
            Abort if a geometry cannot be inferred. Defaults to True.
    
        ignore_geometry : bool, optional
            Opt out on building geometry information, useful for e.g. shot
            organised files. Defaults to False.
    
        endian : {&apos;big&apos;, &apos;msb&apos;, &apos;little&apos;, &apos;lsb&apos;}
            File endianness, big/msb (default) or little/lsb
    
        Returns
        -------
    
        file : segyio.SegyFile
            An open segyio file handle
    
        Raises
        ------
    
        ValueError
            If the mode string contains &apos;w&apos;, as it would truncate the file
    
        Notes
        -----
    
        .. versionadded:: 1.1
    
        .. versionchanged:: 1.8
            endian argument
    
        When a file is opened non-strict, only raw traces access is allowed, and
        using modes such as ``iline`` raise an error.
    
    
        Examples
        --------
    
        Open a file in read-only mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r&quot;) as f:
        ...     print(f.ilines)
        ...
        [1, 2, 3, 4, 5]
    
        Open a file in read-write mode:
    
        &gt;&gt;&gt; with segyio.open(path, &quot;r+&quot;) as f:
        ...     f.trace = np.arange(100)
    
        Open two files at once:
    
        &gt;&gt;&gt; with segyio.open(src_path) as src, segyio.open(dst_path, &quot;r+&quot;) as dst:
        ...     dst.trace = src.trace # copy all traces from src to dst
    
        Open a file little-endian file:
    
        &gt;&gt;&gt; with segyio.open(path, endian = &apos;little&apos;) as f:
        ...     f.trace[0]
    
        &quot;&quot;&quot;
    
        if &apos;w&apos; in mode:
            problem = &apos;w in mode would truncate the file&apos;
            solution = &apos;use r+ to open in read-write&apos;
            raise ValueError(&apos;, &apos;.join((problem, solution)))
    
        endians = {
            &apos;little&apos;: 256, # (1 &lt;&lt; 8)
            &apos;lsb&apos;: 256,
            &apos;big&apos;: 0,
            &apos;msb&apos;: 0,
        }
    
        if endian not in endians:
            problem = &apos;unknown endianness {}, expected one of: &apos;
            opts = &apos; &apos;.join(endians.keys())
            raise ValueError(problem.format(endian) + opts)
    
        from . import _segyio
&gt;       fd = _segyio.segyiofd(str(filename), mode, endians[endian])
E       FileNotFoundError: [Errno 2] No such file or directory

/anaconda/envs/py37_default/lib/python3.7/site-packages/segyio/open.py:162: FileNotFoundError</failure></testcase></testsuite></testsuites>